import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

/**
 * Created by ПАВЕЛ on 17.02.14.
 */
public class DeductionWork {
    private static final String OK = "OK";
    private static final String NEXT = "next";

    private String s;
    private ArrayList<Expression> G;
    private ArrayList<Expression> mainProof;
    private ArrayList<Expression> inputExpressions;
    private ArrayList<Expression> existentialInferences;
    private ArrayList<Expression> universalInferences;
    private ArrayList<ArrayList<Variable>> freeVariables;

    private Expression alpha = null;
    private Expression betta = null;
    private int inputSize;

    public DeductionWork(String s) {
        this.s = s;
        inputSize = 0;
        G = new ArrayList<Expression>();
        mainProof = new ArrayList<Expression>();
        inputExpressions = new ArrayList<Expression>();
        existentialInferences = readFromFile("MPExistential.in");
        universalInferences = readFromFile("MPUniversal.in");
        freeVariables = new ArrayList<ArrayList<Variable>>();
        DeductionExpressionParse();
    }

    public String getString() {
        return s;
    }

    public ArrayList<Expression> getMainProof() {
        return mainProof;
    }

    private ArrayList<Expression> readFromFile(final String fileName) {
        ArrayList<Expression> arrayList = new ArrayList<Expression>();
        try {
            BufferedReader input = new BufferedReader(new FileReader(fileName));
            try {
                String line;
                while ((line = input.readLine()) != null) {
                    arrayList.add(new Parser(line).parse());
                }
            } finally {
                input.close();
            }
        } catch (IOException e) {
            System.err.println("Error: " + e);
        }
        return arrayList;
    }

    /*
    public static Expression getExchange(Expression ex1, Expression ex2) {
        if (ex1 instanceof Variable) {
            if (!ex2.equals(ex1))
                return ex2;
            else return null;
        }
        if (ex1 instanceof BinaryOp && ex2 instanceof BinaryOp) {
            BinaryOp op1 = (BinaryOp) ex1;
            BinaryOp op2 = (BinaryOp) ex2;
            Expression getAns = getExchange(op1.getLeft(), op2.getLeft());
            if (getAns != null) {
                return getAns;
            }
            return getExchange(op1.getRight(), op2.getRight());
        }
        if (ex1 instanceof Quantifier && ex2 instanceof Quantifier) {
            Quantifier q1 = (Quantifier) ex1;
            Quantifier q2 = (Quantifier) ex2;
            Expression getAns = getExchange(q1.getVariable(), q2.getVariable());
            if (getAns != null)
                return getAns;
            return getExchange(q1.getExpression(), q2.getExpression());
        }
        if (ex1 instanceof Predicate && ex2 instanceof Predicate) {
            Predicate p1 = (Predicate) ex1;
            Predicate p2 = (Predicate) ex2;
            ArrayList<Expression> terms1 = p1.getTerms();
            ArrayList<Expression> terms2 = p2.getTerms();
            if (terms1.size() != terms2.size())
                return null;
            for (int i = 0; i < terms1.size(); ++i) {
                Expression ans = getExchange(terms1.get(i), terms2.get(i));
                if (ans != null)
                    return ans;
            }
            return null;
        }

        if (ex1 instanceof Negative && ex2 instanceof Negative) {
            Negative neg1 = (Negative) ex1;
            Negative neg2 = (Negative) ex2;
            return getExchange(neg1.getExpression(), neg2.getExpression());
        }
        return null;
    }
    */

    public static ArrayList<Variable> getVariables(Expression expr) {
        ArrayList<Variable> ans = new ArrayList<Variable>();
        if (expr instanceof Variable) {
            ans.add((Variable) expr);
        }
        if (expr instanceof BinaryOp) {
            BinaryOp op = (BinaryOp) expr;
            ans.addAll(getVariables(op.getLeft()));
            ans.addAll(getVariables(op.getRight()));
        }
        if (expr instanceof Quantifier) {
            Quantifier q = (Quantifier) expr;
            ans.add(q.getVariable());
            ans.addAll(getVariables(q.getExpression()));
        }
        if (expr instanceof Predicate) {
            Predicate p = (Predicate) expr;
            ArrayList<Expression> terms = p.getTerms();
            for (Expression term : terms) {
                ans.addAll(getVariables(term));
            }
        }
        if (expr instanceof Negative) {
            ans.addAll(getVariables(((Negative) expr).getExpression()));
        }
        return ans;
    }

    public static ArrayList<Variable> getChainedVariables(Expression expr) {
        ArrayList<Variable> ans = new ArrayList<Variable>();
        if (expr instanceof BinaryOp) {
            BinaryOp op = (BinaryOp) expr;
            ans.addAll(getChainedVariables(op.getLeft()));
            ans.addAll(getChainedVariables(op.getRight()));
        }
        if (expr instanceof Quantifier) {
            Quantifier q = (Quantifier) expr;
            ans.add(q.getVariable());
        }
        if (expr instanceof Predicate) {
            Predicate p = (Predicate) expr;
            ArrayList<Expression> terms = p.getTerms();
            for (Expression term : terms) {
                ans.addAll(getChainedVariables(term));
            }
        }
        if (expr instanceof Negative) {
            ans.addAll(getChainedVariables(((Negative) expr).getExpression()));
        }
        return ans;
    }

    public static ArrayList<Variable> getFreeVariables(Expression expr) {
        return getFree(expr, new ArrayList<Variable>());
    }

    private static ArrayList<Variable> getFree(Expression expr, ArrayList<Variable> chained) {
        ArrayList<Variable> ans = new ArrayList<Variable>();
        if (expr instanceof Variable) {
            Variable v = (Variable) expr;
            if (!chained.contains(v)) {
                ans.add(v);
            }
        }
        if (expr instanceof BinaryOp) {
            BinaryOp op = (BinaryOp) expr;
            ans.addAll(getFree(op.getLeft(), chained));
            ans.addAll(getFree(op.getRight(), chained));
        }
        if (expr instanceof Quantifier) {
            Quantifier q = (Quantifier) expr;
            boolean fl = chained.contains(q.getVariable());
            if (!fl)
                chained.add(q.getVariable());
            ans.addAll(getFree(q.getExpression(), chained));
            if (!fl)
                chained.remove(q.getVariable());
        }
        if (expr instanceof Predicate) {
            Predicate p = (Predicate) expr;
            ArrayList<Expression> terms = p.getTerms();
            for (Expression term : terms) {
                ans.addAll(getFree(term, chained));
            }
        }
        if (expr instanceof Negative) {
            ans.addAll(getFree(((Negative) expr).getExpression(), chained));
        }
        return ans;
    }

    private static Expression replace(Expression expr, Expression a, Expression b, Expression c, Variable v) {
        if (expr instanceof Predicate) {
            Predicate predicate = (Predicate) expr;
            if ("A".equals(predicate.getName()))
                return a;
            if ("B".equals(predicate.getName()))
                return b;
            if ("C".equals(predicate.getName()))
                return c;
        }

        if (expr instanceof Variable) {
            return expr;
        }

        if (expr instanceof Conjunction) {
            Conjunction conj = (Conjunction) expr;
            return new Conjunction(replace(conj.getLeft(), a, b, c, v), replace(conj.getRight(), a, b, c, v));
        }

        if (expr instanceof Disjunction) {
            Disjunction disj = (Disjunction) expr;
            return new Disjunction(replace(disj.getLeft(), a, b, c, v), replace(disj.getRight(), a, b, c, v));
        }

        if (expr instanceof Implication) {
            Implication impl = (Implication) expr;
            return new Implication(replace(impl.getLeft(), a, b, c, v), replace(impl.getRight(), a, b, c, v));
        }

        if (expr instanceof Negative) {
            Negative neg = (Negative) expr;
            return new Negative(replace(neg.getExpression(), a, b, c, v));
        }

        if (expr instanceof Existential) {
            Existential Existential = (Existential) expr;
            return new Existential(v, replace(Existential.getExpression(), a, b, c, v));
        }

        if (expr instanceof Universal) {
            Universal Universal = (Universal) expr;
            Universal = new Universal(v, replace(Universal.getExpression(), a, b, c, v));
            return Universal;
        }
        return null;
    }

    private String axiomWork(Expression expression) {
        int axiom = isAxiom(expression);
        if (axiom == 11) {
            Universal universal = (Universal) ((Implication) expression).getLeft();
            ArrayList<Variable> busyVariables = getChainedVariables(universal);
            Expression term = ((Implication) expression).getRight();
            //term = getExchange(universal.getExpression(), term);
            term = universal.getExpression().swap(term);
            ArrayList<Variable> variables = getVariables(term);
            if (term != null && !universal.getVariable().equals(term)) {
                for (Variable x : variables) {
                    if (busyVariables.contains(x)) {
                        return "Вывод некорректен начиная с формулы " + inputSize + ": " +
                                "терм " + term.toString() + "не свободен для подстановки в формулу " +
                                universal.getExpression().toString() + " вместо переменной " + universal.getVariable().toString();
                    }
                }
            }
            for (int j = 0; j < freeVariables.size(); ++j) {
                for (int l = 0; l < freeVariables.get(j).size(); ++l) {
                    if (freeVariables.get(j).get(l).equals(universal.getVariable())) {
                        Expression e = alpha;
                        if (j < G.size())
                            e = G.get(j);
                        return "Вывод некорректен начиная с формулы " + inputSize + ": " +
                                "используется схема аксиом с квантором по переменной " + universal.getVariable().toString() +
                                ", входящей свободно в допущение " + e.toString();
                    }
                }
            }
        }

        if (axiom == 12) {
            Existential existential = (Existential) ((Implication) expression).getRight();
            ArrayList<Variable> busyVariables = getChainedVariables(existential);
            busyVariables.add(existential.getVariable());
            Expression term = ((Implication) expression).getLeft();
            //term = getExchange(existential.getExpression(), term);
            term = existential.getExpression().swap(term);

            ArrayList<Variable> variables = getVariables(term);
            if (term != null && !existential.getVariable().equals(term)) {
                for (Variable x : variables) {
                    if (busyVariables.contains(x)) {
                        return "Вывод некорректен начиная с формулы " + inputSize + ": " +
                                "терм " + term.toString() + "не свободен для подстановки в формулу " +
                                existential.getExpression().toString() + " вместо переменной " + existential.getVariable().toString();
                    }
                }
            }
            for (int j = 0; j < freeVariables.size(); ++j) {
                for (int l = 0; l < freeVariables.get(j).size(); ++l) {
                    if (freeVariables.get(j).get(l).equals(existential.getVariable())) {
                        Expression e = alpha;
                        if (j < G.size())
                            e = G.get(j);
                        return "Вывод некорректен начиная с формулы " + inputSize + ": " +
                                "используется схема аксиом с квантором по переменной " + existential.getVariable().toString() +
                                ", входящей свободно в допущение " + e.toString();
                    }
                }
            }
        }
        mainProof.add(expression);
        mainProof.add(new Implication(expression, new Implication(alpha, expression)));
        mainProof.add(new Implication(alpha, expression));
        return OK;
    }

    public String add(Expression expression) {
        ++inputSize;
        inputExpressions.add(expression);

        if (isAxiom(expression) != -1) {
            return axiomWork(expression);
        }

        if (isG(expression)) {
            return OK;
        }

        if (isAlpha(expression)) {
            return OK;
        }

        if (mainProofModusPonens(expression)) {
            return OK;
        }

        String universalRuleResult = isUniversalRule(expression);
        if (!universalRuleResult.equals(NEXT)) {
            return universalRuleResult;
        }

        String existentialRuleResult = isExistentialRule(expression);
        if (!existentialRuleResult.equals(NEXT)) {
            return existentialRuleResult;
        }

        return "Вывод некорректен начиная с формулы " + inputSize;
    }

    private boolean isAlpha(Expression expression) {
        if (expression.equals(alpha)) {
            Expression left = new Implication(alpha, new Implication(alpha, alpha));
            Expression middle = new Implication(alpha, new Implication(new Implication(alpha, alpha), alpha));
            Expression right = new Implication(alpha, alpha);
            mainProof.add(new Implication(alpha, new Implication(alpha, alpha)));
            mainProof.add(new Implication(left, new Implication(middle, right)));
            mainProof.add(new Implication(middle, right));
            mainProof.add(middle);
            mainProof.add(new Implication(alpha, alpha));
            return true;
        }
        return false;
    }

    private boolean isG(Expression expression) {
        for (int i = 0; i < G.size(); ++i)
            if (expression.equals(G.get(i))) {
                mainProof.add(expression);
                mainProof.add(new Implication(expression, new Implication(alpha, expression)));
                mainProof.add(new Implication(alpha, expression));
                return true;
            }
        return false;
    }

    private boolean mainProofModusPonens(Expression expression) {
        for (int j = inputExpressions.size() - 1; j >= 0; --j) {
            Expression mp = inputExpressions.get(j);
            if (mp instanceof Implication) {
                Implication impl = (Implication) mp;
                if (impl.getRight().equals(expression)) {
                    for (int k = inputExpressions.size() - 1; k >= 0; --k) {
                        Expression mp2 = inputExpressions.get(k);
                        if (mp2.equals(impl.getLeft())) {
                            mainProof.add(new Implication(new Implication(alpha, mp2), new Implication(new
                                    Implication(alpha, new Implication(mp2, expression)), new Implication(alpha, expression))));
                            mainProof.add(new Implication(new Implication(alpha, new Implication(mp2, expression)),
                                    new Implication(alpha, expression)));
                            mainProof.add(new Implication(alpha, expression));
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    private String isUniversalRule(Expression expression) {
        if (expression instanceof Implication) {
            Implication impl = (Implication) expression;
            if (impl.getRight() instanceof Universal) {
                Universal forAll = (Universal) impl.getRight();
                for (int j = inputSize - 1; j >= 0; --j) {
                    if (inputExpressions.get(j) instanceof Implication) {
                        Implication impl2 = (Implication) inputExpressions.get(j);
                        if (impl.getLeft().equals(impl2.getLeft()) && forAll.getExpression().equals(impl2.getRight())) {
                            if (getVariables(impl.getLeft()).contains(forAll.getVariable())
                                    && !getChainedVariables(impl.getLeft()).contains(forAll.getVariable())) {
                                return "Вывод некорректен начиная с формулы " + inputSize + ": "
                                        + "переменная " + forAll.getVariable().toString() + " входит свободно в формулу " +
                                        impl.getLeft().toString();
                            }
                            Variable v = forAll.getVariable();
                            for (int k = 0; k < freeVariables.size(); ++k) {
                                for (int l = 0; l < freeVariables.get(k).size(); ++l) {
                                    if (freeVariables.get(k).get(l).equals(v)) {
                                        Expression e = alpha;
                                        if (k < G.size())
                                            e = G.get(k);
                                        return "Вывод некорректен начиная с формулы " + inputSize + ": " +
                                                "используется схема аксиом с квантором по переменной " + v.toString() +
                                                ", входящей свободно в допущение " + e.toString();
                                    }
                                }
                            }
                            for (Expression ex : universalInferences) {
                                mainProof.add(replace(ex, alpha, forAll.getExpression(), impl.getLeft(), forAll.getVariable()));
                            }
                            return OK;
                        }
                    }
                }
            }
        }
        return NEXT;
    }

    private String isExistentialRule(Expression expression) {
        if (expression instanceof Implication) {
            Implication impl = (Implication) expression;
            if (impl.getLeft() instanceof Existential) {
                Existential exists = (Existential) impl.getLeft();
                for (int j = inputSize - 1; j >= 0; --j) {
                    if (inputExpressions.get(j) instanceof Implication) {
                        Implication impl2 = (Implication) inputExpressions.get(j);
                        if (impl.getRight().equals(impl2.getRight()) && exists.getExpression().equals(impl2.getLeft())) {
                            if (getVariables(impl.getRight()).contains(exists.getVariable())
                                    && !getChainedVariables(impl.getRight()).contains(exists.getVariable())) {
                                return "Вывод некорректен начиная с формулы " + inputSize + ": "
                                        + "переменная " + exists.getVariable().toString() + " входит свободно в формулу " +
                                        impl.getRight().toString();
                            }
                            Variable v = exists.getVariable();
                            for (int k = 0; k < freeVariables.size(); ++k) {
                                for (int l = 0; l < freeVariables.get(k).size(); ++l) {
                                    if (freeVariables.get(k).get(l).equals(v)) {
                                        Expression e = alpha;
                                        if (k < G.size())
                                            e = G.get(k);
                                        return "Вывод некорректен начиная с формулы " + inputSize + ": " +
                                                "используется схема аксиом с квантором по переменной " + v.toString() +
                                                ", входящей свободно в допущение " + e.toString();
                                    }
                                }
                            }
                            for (Expression ex : existentialInferences) {
                                mainProof.add(replace(ex, alpha, exists.getExpression(), impl.getRight(), exists.getVariable()));
                            }
                            return OK;
                        }
                    }
                }
            }
        }
        return NEXT;
    }

    private int isAxiom(Expression expression) {
        return Axioms.isAxiom(expression);
    }

    private void DeductionExpressionParse() {
        int brackets = 0;
        int afterLastComma = 0;
        for (int i = 0; i < s.length(); ++i) {
            if (s.charAt(i) == '(') ++brackets;
            if (s.charAt(i) == ')') --brackets;
            if (s.charAt(i) == ',' && brackets == 0) {
                G.add(new Parser(s.substring(afterLastComma, i)).parse());
                freeVariables.add(getFreeVariables(G.get(i)));
            }
        }
        alpha = new Parser(s.substring(afterLastComma, s.indexOf("|-"))).parse();
        freeVariables.add(getFreeVariables(alpha));
        betta = new Parser(s.substring(s.indexOf("|-") + 2, s.length())).parse();

    }
}
